---
title: "Untitled"
output: html_document
date: '2022-10-18'
---


### 1. Introduction

HaploQA is a web application developed by Kieth Sheppard for The Reinholdt's Lab in 2015 for the purpose of storing, increasing accessibility and quality controlling of micro array mice genotyping data. According to the HaploQA about website, 'On the import of a sample, the haplotype probabilities that are represented in the plots are calculated.' and the haplotype reconstruction process for the contributing founder strains is then done based on the calculated probabilities. The source codes of HaploQA was written in Python 3.

R/qtl2 is an open-source software package built in 2019, which not only performs similar haplotype reconstruction tasks as HaploQA but also has the functionality to perform other computations such as genetic mapping - in the pipeline developed for this project,the software takes genotyping data as input, calculate the haplotype probabilities based on a Hidden Markov Model algorithm, then perform haplotype reconstructions based on the quantitative results. 

Since R/qtl2 was built more recently and is currently maintained by the developers, the Jackson Laboratory is considering transitioning from HaploQA to R/qtl2 generalized AIL (Advanced intercross lines)  for similar haplotype reconstructing tasks with genotyping data. The main purpose of this project is to decide if the transition should be made determine based on whether HaploQA or R/qtl2 genail provides more accurate haplotype reconstruction results.

The best way to determine which method provides more accurate results is to compare the results of the two methods each to the 'correct' results - in R/qtl2, there exists some cross-specific models which the Hidden Markov model was tailored to generate the most accurate results for a particular cross. These models will be referred to as the 'truth' models in this document. 

In this project, we selected some GigaMUGA crosses, developed pipelines that retrieve genotyping data used in the initial HaploQA algorithm, performs haplotype reconstruction computations for both qtl2 genail and haploqa, and compare the percentages of markers within each method that agree with the optimal model of the according crosses to determine whether HaploQA or R/qtl2 gen-AIL would be the most appropriate for similar haplotype reconstruction tasks. The analysis was also done for MiniMUGA, as it is the standard cross type JAX uses for mutant mice, however, there is no tailored truth model for MiniMUGA, so the amount of marker differences between HaploQA and qtl2 was used as the main metrics for MiniMUGA to determine the model performances.


### 2. Methods

The main repository is https://github.com/TheJacksonLaboratory/HaploQA_qtl2_comp which contains the main pipelines developed for this project, all utility functions, and visualizations of selected results.
  
The pipelines developed for this project is stored in the script, 'haplotype_reconstruction_pipelines.R', which is stored in the same working directory as this report and is sourced below:
  
```{r}

library(rstudioapi)
library(qtl2)
library(dplyr)
library(tidyverse)
library(httr)
library(rvest)
library(data.table)
library(qtl2convert)
library(ggrepel)
library(reshape2)
library(stats)
library(ggplot2)
library(stringr)
library(stringi)
library(lsa)
library(readr)

root <- dirname(getSourceEditorContext()$path)
source(paste0(root,"/input_data_prep_functions.R"))

#source(paste0(root,"/haplotype_reconstruction_pipelines.R"))


```

As mentioned in the introduction, in order to decide whether to transition, the accuracy of haploqa and qtl2 each need to be compared to an optimal model. The pipelines in the sources script perform haplotype reconstruction tasks using genotyping data obtained from different types of data sources, specifically, 5 sets of GigaMUGA samples (Collaborative Cross, Diversity Outbred, F3, F2, and a GigaMUGA mutant cross), 70 individuals within the MiniMUGA sample. Decision was made to not include Muga/MegaMUGA data due to the discontinued usage of the array types.

#### 2.2. Data Retrieval 

Input data was retrieved from haploqa.jax.org, and converted into the qtl2 input format. The data wrangling consists of two parts:
1. scrapes the HTML elements of the haploqa website and downloads the SNP level reports for each individual within each cross
2. concatenate the individuals within each cross into a single genotype file, converts the genotype file into the required input files for qtl2

However, haploqa.jax.org contains a large number of uploaded samples and the input data for each cross needs to be retrieved from their according sample. For example, for cross 'Collaborative Cross', the URL to the sample is http://haploqa-dev.jax.org/tag/Collaborative%20Cross.html 

A configuration file, 'annotations_config.csv', is stored in the environment, which allows the pipeline to automatically obtain all relevant information associated with each cross such as the sample URL, input data directory, output data directory, marker annotation file names, etc. 
The purpose of this configuration file is to avoid having to pass a large list of parameters into each pipeline function.

A preview of the configuration file is shown as below:

```{r}
#root <- dirname(rstudioapi::getSourceEditorContext()$path)
config <- fread(paste0(root, '/annotations_config.csv'))
print(config)
```

Below is an example of how the pipeline set-up looks like for CC:

```{r}
# cross type
sample_type <- 'CC'
### Environment
config_sample <- config[config$array_type == sample_type] # get config info for this cross type
marker_type <- config_sample$marker_type # type of marker (GigaMUGA/MiniMUGA)
founders_list <- unlist(strsplit(config_sample$founders_list, ", ")) # contributing founders
n_founders <- length(founders_list) # number of founders used in reconstruction
ngen <- config_sample$ngen # ngen parameter used in cross
sample_url <- config_sample$url # URL to retrieve data from haploqa for this cross
founder_url <- config_sample$founder_url # URL to retrieve founder data for GigaMUGA/MiniMUGA
truth_model <- config_sample$truth_model # cross type of truth model for the cross


# directory to store input data retrieved from haploqa
data_dir <- file.path(root, config_sample$data_dir)
# directory to store input data for qtl2
qtl2_dir <- file.path(root, config_sample$qtl2_dir)
```

There are three major pipelines in the repository:
a. 'haplotype_reconstruction_pipeline' - haplotype reconstructions for an entire cross (all individuals within the cross) 
b. 'sample_haplotype_reconstruction' - haplotype reconstructions for one individual 
c. 'truth_model_reconstruction' - haplotype reconstructions for optimal/truth models

Some crosses, such as DO and CC, have the same contributing founders across all individuals. The haplotype reconstructions can therefore be conducted for all individuals in the entire cross at the same time. The pipeline 'haplotype_reconstruction_pipeline' can be used for crosses with consistent contributing founders for such purpose. Whereas the mutant crosses, such as MiniMUGA, contains individuals with mutate mice where all individuals may have different contributing founder strains. Haplotype reconstructions for these types of crosses need to conducted individually for each sample, and therefore, the pipeline 'sample_haplotype_reconstruction' should be used.

The below results section will demonstrate how the pipelines are used for each cross and the results generated from them.

#### 2.3. Results

##### 2.3.1. GigaMUGA

The pipeline for GigaMUGA executes all the individuals within the sample. The contributing founders for all individuals within the GigaMUGA samples are always the same.

```{r}
# simulated phenotypes
list_pheno <- c('WBC', 'NEUT')
```

1. Results for DO:

```{r}
do_results <- haplotype_reconstruction_pipeline('DO', list_pheno, qtl2_file_gen = F, samples_gen = F, truth_model = F)

```

Below are the genotype visualizations for some individuals: 

```{r}
plot_onegeno_test(do_results[['ph_geno']], do_results[['ph_geno_haploqa']], do_results[['map']], ind = 1, 
                          shift = TRUE, main = paste0('qtl2 - Geno-wide genotypes of individual ', 1),
                          sub = 'Left - qtl2, Right - HaploQA') 
```


```{r}
plot_onegeno_test(do_results[['ph_geno']], do_results[['ph_geno_haploqa']], do_results[['map']], ind = 50, 
                          shift = TRUE, main = paste0('qtl2 - Geno-wide genotypes of individual ', 50),
                          sub = 'Left - qtl2, Right - HaploQA') 
```

2. Results for CC:

```{r}
cc_results <- haplotype_reconstruction_pipeline('CC', list_pheno, qtl2_file_gen = F, samples_gen = F, truth_model = F)

```

Genotype visualizations for some individuals: 

```{r}
plot_onegeno_test(cc_results[['ph_geno']], cc_results[['ph_geno_haploqa']], cc_results[['map']], ind = 1, 
                          shift = TRUE, main = paste0('qtl2 - Geno-wide genotypes of individual ', 1),
                          sub = 'Left - qtl2, Right - HaploQA') 
```


```{r}
plot_onegeno_test(cc_results[['ph_geno']], cc_results[['ph_geno_haploqa']], cc_results[['map']], ind = 50, 
                          shift = TRUE, main = paste0('qtl2 - Geno-wide genotypes of individual ', 50),
                          sub = 'Left - qtl2, Right - HaploQA') 
```

3. Results for BXD F3:

```{r}
bxd_results <- haplotype_reconstruction_pipeline('BXD', list_pheno, qtl2_file_gen = F, samples_gen = F)

```

Genotype visualizations for some individuals: 

```{r}
plot_onegeno_test(bxd_results[['ph_geno']], bxd_results[['ph_geno_haploqa']], bxd_results[['map']], ind = 1, 
                          shift = TRUE, main = paste0('qtl2 - Geno-wide genotypes of individual ', 1),
                          sub = 'Left - qtl2, Right - HaploQA') 
```


```{r}
plot_onegeno_test(bxd_results[['ph_geno']], bxd_results[['ph_geno_haploqa']], bxd_results[['map']], ind = 50, 
                          shift = TRUE, main = paste0('qtl2 - Geno-wide genotypes of individual ', 50),
                          sub = 'Left - qtl2, Right - HaploQA') 
```

4. Results for F2:

```{r}
f2_results <- haplotype_reconstruction_pipeline('F2', list_pheno, qtl2_file_gen = F, samples_gen = F)
```

Genotype visualizations for some individuals: 

```{r}
plot_onegeno_test(f2_results[['ph_geno']], f2_results[['ph_geno_haploqa']], f2_results[['map']], ind = 1, 
                          shift = TRUE, main = paste0('qtl2 - Geno-wide genotypes of individual ', 1),
                          sub = 'Left - qtl2, Right - HaploQA') 
```


```{r}
plot_onegeno_test(f2_results[['ph_geno']], f2_results[['ph_geno_haploqa']], f2_results[['map']], ind = 50, 
                          shift = TRUE, main = paste0('qtl2 - Geno-wide genotypes of individual ', 50),
                          sub = 'Left - qtl2, Right - HaploQA') 
```

5. GigaMUGA Mutant cross

```{r}

### GigaMUGA mutant
gigamuga_url <- 'http://haploqa-dev.jax.org/tag/Jackson_Lab_Mahaffey_MURGIGV01_20160102_FinalReport.html'
url_domain <- 'http://haploqa-dev.jax.org/'
marker_type <- 'GigaMUGA'
html_table <- read_html(gigamuga_url) %>% html_nodes("a") %>% html_attr("href")
url_list <- paste0(url_domain, html_table[grepl('/sample', html_table)])
summary_df <- sample_summary_scrape(read_html(gigamuga_url), url_list, marker_type)
summary_df$`% No Call` <- as.numeric(gsub("%", "", summary_df$`% No Call`))
summary_df <- summary_df[summary_df$`% No Call` < 10,]

ind_gm <- summary_df[summary_df$`Haplotype Candidate` == 'False',]$`ID`
ind_gm <- ind_gm[!ind_gm %in% ind_gm[1:44]] # founder not in UWisc dictionary (SJL)
ind_gm <- ind_gm[!ind_gm %in% ind_gm[4:24]] # empty - Q2-QP
ind_gm <- ind_gm[!ind_gm %in% c('QU', 'SM', 'SX', 'T5', 'TG', 'TR', 'TS', 'TX', 'UF', 'UR', 'VA', 'VE', 'VG', 'VK', 'VN', 'W4', 'XS', 'Y8', 'Z8', 'ZG')] # screentime error
ind_gm <- ind_gm[!ind_gm %in% c('RY', 'S8', 'SG', 'SR', 'Y2', 'YA', 'YJ', 'YT')] # only one founder
ind_gm <- ind_gm[!ind_gm %in% c('U2', 'UA', 'UJ' ,'UT', 'W5', 'WD', 'WN', 'XZ', 'Y9', 'YH', 'YS')] # SJL 
ind_gm <- ind_gm[!ind_gm %in% c('UK', 'UU', 'V4')] #C57BLKS/J
ind_gm <- ind_gm[!ind_gm %in% c('WX', 'X7', 'X8', 'XF', 'XG', 'XQ', 'XR', 'XY', 'YG', 'YR')] # 129P3
ind_gm <- ind_gm[!ind_gm %in% c('WY')] # FVB/NJ
ind_gm <- ind_gm[!ind_gm %in% c('X2', 'X3', 'X4', 'X5', 'XA', 'XB', 'XC', 'XD', 'XJ', 'XK', 'XM', 'XN', 'XT', 'XU', 'XV', 'XW', 'Y2', 'Y3', 'Y4', 'Y5', 'YB', 'YC', 'YD', 'YE', 'YK', 'YM', 'YN', 'YP', 'YU', 'YV', 'YW', 'YX', 'Z5', 'Z6', 'Z7', 'ZC', 'ZD', 'ZE', 'ZF', 'ZM', 'ZN', 'ZP', 'ZQ', 'ZV', 'ZW', 'ZX', 'ZY', 'PY', 'Z3', 'ZB' ,'ZK', 'ZU')] # empty ones

gigamuga_results <- list()
for (ind in ind_gm) {
  print(ind)
  sample_gm_res <- sample_haplotype_reconstruction('MURGIGV01', ind, samples_gen = T, qtl2_file_gen = T)
  gigamuga_results[[ind]] <- sample_gm_res
}
```


##### 2.3.2. MiniMUGA

```{r}
### MiniMUGA pipeline
minimuga_url <- 'http://haploqa-dev.jax.org/tag/MiniMUGA.html'
url_domain <- 'http://haploqa-dev.jax.org/'
marker_type <- 'MiniMUGA'
html_table <- read_html(minimuga_url) %>% html_nodes("a") %>% html_attr("href")
url_list <- paste0(url_domain, html_table[grepl('/sample', html_table)])
summary_df <- sample_summary_scrape(read_html(minimuga_url), url_list, marker_type)
ind_mini <- summary_df[summary_df$`Haplotype Candidate` == 'False',]$`ID`
ind_mini <- ind_mini[ind_mini!='JXX'] # screentime error, skip this one
ind_mini <- ind_mini[ind_mini!='JY9'] # only 1 contributing strain, AIL incompatible, skip this one as well
ind_mini <- ind_mini[ind_mini!='JY6'] # temporary - JXU, JY3, JY5
minimuga_results <- list()
mini_pct_res <- list()
for (ind in ind_mini) {
  #ind <- 'JXN'
  print(ind)
  sample_mini_res <- sample_haplotype_reconstruction('MiniMUGA', ind, samples_gen = F, qtl2_file_gen = F)
  
  df <- minimuga_geno_comp(sample_mini_res, ind, 'MiniMUGA')
  
  minimuga_results[[ind]] <- sample_mini_res
  mini_pct_res[[ind]] <- df
}

```


##### 2.3.3. Shiny Visualizations

```{r}
source(paste0(root,"/app.R"))
shinyApp(ui, server)
```


#### 3.Statistical Results

There are three parts of the comparison:
1. haploqa results, which can be obtained directly from haploqa.jax.org by downloading the SNP level haplotype reports from each sample. 
2. qtl2 genAIL results, which was calculated using the R package 'qtl2' with the crosstypes 'genail'
3. qtl2 best model, which was calculated using the qtl2package with the original crosstype 

##### 3.1. Truth models

At a glance of the visualizations which present a high-level idea of the difference between the haplotype reconstruction results between qtl2 and haploqa, there are some visible differences between the two models - specifically, qtl2 appears to have more crossovers and come minor areas appear to have different founder results. To determine which model is more correct, some 'truth' models, which the algorithms have been used (for a long time?), were also constructed for each of the crosses.

As mentioned in the configuration file, the truth model for CC uses crosstype 'risib8', the truth model for DO uses crosstype 'do', the truth model for BXD F3 uses crosstype 'ail', and the truth model for F2 uses crosstype 'f2'. The executions of pipelines for the truth models are as shown below:

```{r}
do_truth_results <- truth_model_reconstruction('DO', list_pheno, qtl2_file_gen = F, samples_gen = F)
cc_truth_results <- truth_model_reconstruction('CC', list_pheno, qtl2_file_gen = F, samples_gen = F)
bxd_truth_results <- truth_model_reconstruction('BXD', list_pheno, qtl2_file_gen = F, samples_gen = F)
f2_truth_results <- truth_model_reconstruction('F2', list_pheno, qtl2_file_gen = F, samples_gen = F)
```


##### 3.2. Quantitative comparisons
Combining the results of the truth model, the qtl2 haplot
(Display the csvs, and perhaps the visualizations here too)


```{r}
# filepath to the csvs
shiny_pct_fp <- file.path(results_dir, 'shiny_pct_csvs') 

# DO
do_pct_df <- fread(file.path(shiny_pct_fp, 'do_truth_comp.csv'))
do_pct_df
```


```{r}
# CC
cc_pct_df <- fread(file.path(shiny_pct_fp, 'cc_truth_comp.csv'))
cc_pct_df
#cc_pct_df
#ggplot(cc_pct_df) + aes(x = qtl2_pct_diff, y = haploqa_pct_diff) + geom_point()
```


```{r}
# BXD f3
bxd_pct_df <- fread(file.path(shiny_pct_fp, 'bxd_truth_comp.csv'))
bxd_pct_df

```


```{r}
# BXD f3
f2_pct_df <- fread(file.path(shiny_pct_fp, 'f2_truth_comp.csv'))
f2_pct_df

```

```{r}
do_qtl2_truth_diff <- do_pct_df$qtl2_pct_diff
cc_qtl2_truth_diff <- cc_pct_df$qtl2_pct_diff
bxd_qtl2_truth_diff <- bxd_pct_df$qtl2_pct_diff
f2_qtl2_truth_diff <- f2_pct_df$qtl2_pct_diff

# align lengths
max_n <- max(nrow(do_pct_df), nrow(cc_pct_df), nrow(bxd_pct_df), nrow(f2_pct_df))

length(do_qtl2_truth_diff) <- max_n 
length(cc_qtl2_truth_diff) <- max_n
length(bxd_qtl2_truth_diff) <- max_n
length(f2_qtl2_truth_diff) <- max_n

df_qtl2_truth_diff <- as.data.frame(cbind('do' = do_qtl2_truth_diff, 'cc' = cc_qtl2_truth_diff, 'f3' = bxd_qtl2_truth_diff, 'f2' = f2_qtl2_truth_diff))
plot_df <- melt(df_qtl2_truth_diff)

library(ggplot2)    
ggplot(plot_df) + geom_boxplot(aes(x = variable, y = value)) + ggtitle('qtl2 - proportion concordance between optimal and implemented models')
```

According to the visualization, which shows the percentage of marker differences between qtl2 genail and the truth models - DO, F3 and F2 are all producing results that are almost exactly the same as the optimal model, with CC having some discrepancies. We believe the reason why CC performs so differently is that the optimal model for CC does not allow any heterozygosity, whereas the genail does, so the genail model showed some residual heterozygosity from the CC mice which the optimal model does not have the ability to show. 

```{r}
do_haploqa_truth_diff <- do_pct_df$haploqa_pct_diff
cc_haploqa_truth_diff <- cc_pct_df$haploqa_pct_diff
bxd_haploqa_truth_diff <- bxd_pct_df$haploqa_pct_diff
f2_haploqa_truth_diff <- f2_pct_df$haploqa_pct_diff

# align lengths
max_n <- max(nrow(do_pct_df), nrow(cc_pct_df), nrow(bxd_pct_df), nrow(f2_pct_df))

length(do_haploqa_truth_diff) <- max_n 
length(cc_haploqa_truth_diff) <- max_n
length(bxd_haploqa_truth_diff) <- max_n
length(f2_haploqa_truth_diff) <- max_n

df_haploqa_truth_diff <- as.data.frame(cbind('do' = do_haploqa_truth_diff, 'cc' = cc_haploqa_truth_diff, 'f3' = bxd_haploqa_truth_diff, 'f2' = f2_haploqa_truth_diff))
plot_df <- melt(df_haploqa_truth_diff)

library(ggplot2)    
ggplot(plot_df) + geom_boxplot(aes(x = variable, y = value)) + ggtitle('haploqa - proportion concordance between optimal and implemented models')
```


According to the visualization, which shows the percentage of marker differences between haploqa and the truth models - the haploqa results for f2 and f3 still seem to be similar to the optimal model, but DO and CC seem to be relatively incorrect results.

```{r}
do_haploqa_truth_diff <- do_pct_df$haploqa_qtl2_pct_diff
cc_haploqa_truth_diff <- cc_pct_df$haploqa_qtl2_pct_diff
bxd_haploqa_truth_diff <- bxd_pct_df$haploqa_qtl2_pct_diff
f2_haploqa_truth_diff <- f2_pct_df$haploqa_qtl2_pct_diff

# align lengths
max_n <- max(nrow(do_pct_df), nrow(cc_pct_df), nrow(bxd_pct_df), nrow(f2_pct_df))

length(do_haploqa_truth_diff) <- max_n 
length(cc_haploqa_truth_diff) <- max_n
length(bxd_haploqa_truth_diff) <- max_n
length(f2_haploqa_truth_diff) <- max_n

df_haploqa_truth_diff <- as.data.frame(cbind('do' = do_haploqa_truth_diff, 'cc' = cc_haploqa_truth_diff, 'f3' = bxd_haploqa_truth_diff, 'f2' = f2_haploqa_truth_diff))
plot_df <- melt(df_haploqa_truth_diff)

library(ggplot2)    
ggplot(plot_df) + geom_boxplot(aes(x = variable, y = value)) + ggtitle('proportion concordance between implemented models (haploqa vs qtl2)')
```


```{r}
mean_df <- rbind(t((colMeans(do_pct_df[,2:4]))), t((colMeans(cc_pct_df[,2:4]))), t((colMeans(bxd_pct_df[,2:4]))), t((colMeans(f2_pct_df[,2:4])))) %>% as.data.frame()
colnames(mean_df) <- paste(colnames(mean_df), "mean", sep = "_")

mean_df$sample_type <- c('DO', 'CC', 'F3', 'F2')
mean_df %>% select(sample_type, everything())
colMeans(cc_pct_df[,2:4])
```

MiniMUGA

```{r}
mini_plot <- mini_pct_res %>% group_by(sample_id) %>% summarise(qtl2_pct_diff = sum(haplo_diplotype != qtl2_calls)/n()) %>% as.data.frame()
plot_df <- melt(mini_plot)
plot_df$variable <- 'MiniMUGA'
   
ggplot(plot_df) + geom_boxplot(aes(x = variable, y = value)) + ggtitle('MiniMUGA - percentage of marker difference between genail and haploqa') + xlab('model')

```

The MiniMUGA samples are mutant mice samples, meaning they often have founders that contribute to only a few markers. The above boxplot shows a relatively significant high number of markers that are different between haploQA and qtl2 genail, which shows a weakness for qtl2: due to the way HMM models determines genome states based on probabilities - when they are extra founders, or founders that only contribute to a few markers, qtl2 genail tends to be 'confused' and bounce states in the haplotype reconstruction process, whereas haploQA is capable of staying in states.

#### 4. Conclusion - TBD
Overall, the existing results for qtl2 genail and haploqa show that the two methods have very similar performance for most of the crosses, with genail performing significantly better for the DO outbred mice samples. HaploQA handles the extra founders being present in the haplotype reconstruction process better, however, qtl2 genail model has stronger capabilities to produce more accurate results for complicated crosses. So based on the results we have so far, we’re leaning toward that genail is more accurate than haploqa.

#### 5. References
1. http://haploqa-dev.jax.org/help.html

2. Broman KW, Gatti DM, Simecek P, Furlotte NA, Prins P, Sen Ś, Yandell BS, Churchill GA. R/qtl2: Software for Mapping Quantitative Trait Loci with High-Dimensional Data and Multiparent Populations. Genetics. 2019 Feb;211(2):495-502. doi: 10.1534/genetics.118.301595. Epub 2018 Dec 27. PMID: 30591514; PMCID: PMC6366910.


